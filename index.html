<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Te Amo Sorpresa — Animated Hearts</title>
  <style>
    :root{
      --bg1:#4a1b5f;
      --bg2:#0e1c39;
      --accent:#ff4f7a;
      --pink:#fa4f86;
    }
    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(ellipse at bottom, var(--bg1) 0%, var(--bg2) 100%);
      font-family: "Arial Rounded MT Bold", Arial, system-ui, -apple-system, "Segoe UI", Roboto;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }
    canvas { display:block; position:absolute; left:0; top:0; width:100vw; height:100vh; }
    #stars-bg { z-index:0; pointer-events:none; }
    #surprise-canvas { z-index:1; pointer-events:none; display:block; }
  </style>
</head>
<body>
  <canvas id="stars-bg"></canvas>
  <canvas id="surprise-canvas"></canvas>

  <script>
  (function(){
    const starsCanvas = document.getElementById('stars-bg');
    const starsCtx = starsCanvas.getContext('2d');
    const canvas = document.getElementById('surprise-canvas');
    const ctx = canvas.getContext('2d');

    function resize(){
      starsCanvas.width = window.innerWidth;
      starsCanvas.height = window.innerHeight;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // STAR BACKGROUND
    let stars = [];
    function initStars(){
      stars = [];
      const w = starsCanvas.width, h = starsCanvas.height;
      const layers = [0.3,0.7,1];
      const counts = [60, 36, 20];
      const colors = ['#fff','#aef','#ffe6f0'];
      for(let l=0;l<layers.length;l++){
        for(let i=0;i<counts[l];i++){
          stars.push({
            x: Math.random()*w,
            y: Math.random()*h,
            r: Math.random()*(1.4 + l*0.6)+0.6,
            a: Math.random()*Math.PI*2,
            tw: Math.random()*0.8+0.2,
            layer: layers[l],
            color: colors[l]
          });
        }
      }
    }
    initStars();

    let shootingStar = { active:false, p:0, x0:0, y0:0, dx:0, dy:0 };
    function maybeSpawnShootingStar(){
      if(!shootingStar.active && Math.random()<0.006){
        shootingStar.active = true;
        shootingStar.p = 0;
        shootingStar.x0 = Math.random()*starsCanvas.width*0.4 + starsCanvas.width*0.05;
        shootingStar.y0 = Math.random()*starsCanvas.height*0.25 + starsCanvas.height*0.03;
        shootingStar.dx = Math.random()*140 + 80;
        shootingStar.dy = Math.random()*50 + 30;
      }
    }

    function drawStars(){
      const w=starsCanvas.width, h=starsCanvas.height;
      starsCtx.clearRect(0,0,w,h);
      for(const s of stars){
        s.a += 0.012 + s.tw*0.01;
        const alpha = 0.55 + Math.sin(s.a)*0.35;
        const px = s.x + Math.sin(s.a*0.13)*6*s.layer;
        const py = s.y + Math.cos(s.a*0.16)*4*s.layer;
        starsCtx.beginPath();
        starsCtx.arc(px,py,s.r,0,Math.PI*2);
        starsCtx.fillStyle = `rgba(${s.color === '#fff' ? '255,255,255' : s.color === '#aef' ? '170,238,255' : '255,230,240'},${alpha})`;
        starsCtx.shadowColor = s.color;
        starsCtx.shadowBlur = 8*s.layer;
        starsCtx.fill();
        starsCtx.shadowBlur = 0;
      }
      if(shootingStar.active){
        let p = shootingStar.p;
        if(p<1){
          const x = shootingStar.x0 + shootingStar.dx*p;
          const y = shootingStar.y0 + shootingStar.dy*p;
          starsCtx.save();
          starsCtx.globalAlpha = 0.75;
          starsCtx.strokeStyle = "#fff";
          starsCtx.lineWidth = 2.6;
          starsCtx.beginPath();
          starsCtx.moveTo(x-shootingStar.dx*0.22, y-shootingStar.dy*0.22);
          starsCtx.lineTo(x,y);
          starsCtx.stroke();
          starsCtx.restore();
          shootingStar.p += 0.01 + Math.random()*0.01;
        } else {
          shootingStar.active=false;
        }
      } else {
        maybeSpawnShootingStar();
      }
      requestAnimationFrame(drawStars);
    }
    drawStars();

    // HEART TARGETS
    function generateHeartTargets(w,h,count){
      const cx = w/2, cy = h*0.44;
      const scale = Math.min(w,h)/3.6;
      const pts = [];
      for(let i=0;i<count;i++){
        const t = i/(count-1);
        const a = Math.PI*(1.12*t + 0.18);
        const px = cx + Math.sin(a)*scale*(1 - 0.22*Math.abs(t-0.5));
        const py = cy - (Math.cos(a)*scale + 38*Math.abs(t-0.5));
        pts.push({x:px, y:py});
      }
      return pts;
    }

    // Heart lifecycle
    const hearts = [];
    let targets = [];
    let totalHearts = 96;
    let shootDurationMs = 3300;
    let startAt = 0;
    let center = { x: 0, y: 0 };
    let turretPositions = { left:{x:60,y:0}, right:{x:0,y:0} };

    function initHearts(){
      hearts.length = 0;
      targets = generateHeartTargets(canvas.width, canvas.height, totalHearts);
      center.x = canvas.width/2;
      center.y = canvas.height*0.44;
      turretPositions.left = {x:60, y: canvas.height - 68};
      turretPositions.right = {x: canvas.width - 60, y: canvas.height - 68};
      for(let i=0;i<totalHearts;i++){
        const tgt = targets[i];
        const fromSide = (i%2===0) ? 'left' : 'right';
        const startMs = Math.round((i / (totalHearts-1)) * shootDurationMs);
        hearts.push({
          id:i,
          target: {x: tgt.x, y: tgt.y},
          side: fromSide,
          state: 'waiting',
          tStart: startMs,
          tFly: 0, tPick:0, tDeliver:0,
          from: null, cp: null,
          x: 0, y:0, scale:0.6, alpha:0,
          rot: Math.random()*Math.PI*2,
          pickedAt: null
        });
      }
    }
    initHearts();

    function nowMs(){ return performance.now(); }
    function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
    function easeInOutSine(t){ return 0.5 - 0.5*Math.cos(Math.PI*t); }

    let animationTick = 0;
    let last = nowMs();
    let rotating = false, rotationStart=0, rotationDuration=900;
    let dancing = false, danceStart=0;

    function start(){
      startAt = nowMs();
      initHearts();
      rotating = false;
      animationTick = 0;
      dancing = false;
      last = nowMs();
      // prepare bezier points
      for(const h of hearts){
        const from = (h.side==='left') ? turretPositions.left : turretPositions.right;
        h.from = {x: from.x, y: from.y};
        const midx = (from.x + h.target.x)/2 + (h.side==='left' ? -90 : 90);
        const midy = Math.min(from.y, h.target.y) - 140 - (Math.random()*30);
        h.cp = {x: midx + (Math.random()*30-15), y: midy + (Math.random()*20-10)};
        h.state='waiting';
        h.tFly = 0; h.tPick=0; h.tDeliver=0;
        h.x = from.x; h.y = from.y;
        h.scale = 0.5 + Math.random()*0.2;
        h.alpha = 0.0;
      }
      requestAnimationFrame(loop);
    }

    function loop(){
      const ms = nowMs();
      const elapsed = ms - startAt;
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);

      let allArrived = true;
      for(const h of hearts){
        if(ms - startAt >= h.tStart && h.state === 'waiting'){
          h.state = 'flying';
          h.tFly = 0;
          h.flyDuration = 600 + (Math.random()*240 - 120);
          h.pickThreshold = 0.45 + (Math.random()*0.12 - 0.06);
        }
        if(h.state === 'flying'){
          h.tFly += (ms - last);
          let p = Math.min(h.tFly / h.flyDuration, 1);
          const ep = easeOutCubic(p);
          const bx = (1-ep)*(1-ep)*h.from.x + 2*(1-ep)*ep*h.cp.x + ep*ep*h.target.x;
          const by = (1-ep)*(1-ep)*h.from.y + 2*(1-ep)*ep*h.cp.y + ep*ep*h.target.y;
          h.x = bx; h.y = by;
          h.scale = 0.48 + 0.5*ep;
          h.alpha = 0.25 + 0.75*ep;
          h.rot *= 0.99;
          if(p >= h.pickThreshold){
            h.state = 'picked';
            h.pickedAt = ms;
            h.tPick = 0;
            h.pickDuration = 260 + Math.random()*240;
            h.pickFrom = {x:h.x, y:h.y};
            h.centerOffset = {x:(Math.random()*1-0.5)*30, y:(Math.random()*1-0.5)*18};
          }
        } else if(h.state === 'picked'){
          h.tPick += (ms - last);
          const p = Math.min(h.tPick / h.pickDuration, 1);
          const ep = easeInOutSine(p);
          const tx = center.x + h.centerOffset.x;
          const ty = center.y + h.centerOffset.y;
          h.x = h.pickFrom.x*(1-ep) + tx*ep;
          h.y = h.pickFrom.y*(1-ep) + ty*ep;
          h.scale = 0.7 + 0.3*ep;
          h.alpha = 0.7 + 0.3*ep;
          h.rot *= 0.98;
          if(p >= 1){
            h.state = 'holding';
            h.holdFor = 80 + Math.random()*220;
            h.holdStart = ms;
          }
        } else if(h.state === 'holding'){
          const tSince = ms - h.holdStart;
          h.x = center.x + h.centerOffset.x + Math.sin(tSince*0.006 + h.id)*8;
          h.y = center.y + h.centerOffset.y + Math.cos(tSince*0.005 + h.id)*6;
          if(ms - h.holdStart >= h.holdFor){
            h.state = 'delivering';
            h.tDeliver = 0;
            h.deliverDuration = 420 + Math.random()*260;
            h.relTarget = { x: h.target.x - center.x, y: h.target.y - center.y };
          }
        } else if(h.state === 'delivering'){
          h.tDeliver += (ms - last);
          const p = Math.min(h.tDeliver / h.deliverDuration, 1);
          const ep = easeOutCubic(p);
          const startX = center.x + h.centerOffset.x;
          const startY = center.y + h.centerOffset.y;
          h.x = startX*(1-ep) + (h.target.x)*ep;
          h.y = startY*(1-ep) + (h.target.y)*ep;
          h.scale = 0.85 + 0.15*ep;
          h.alpha = 0.9;
          h.rot = (1-p)*h.rot*0.5;
          if(p>=1){
            h.state = 'arrived';
            h.arrivedAt = ms;
            h.x = h.target.x; h.y = h.target.y;
            h.scale = 1;
            h.alpha = 1;
          }
        }
        if(h.state !== 'arrived') allArrived = false;
      }

      const anyActive = hearts.some(h=> h.state !== 'waiting' && h.state !== 'arrived');
      if(hearts.every(h=>h.state==='arrived') && hearts.length>0){
        if(!rotating){
          rotating = true;
          rotationStart = ms;
          rotationDuration = 900;
        }
      }

      let rotationAngle = 0;
      if(rotating){
        const t = Math.min((ms - rotationStart)/rotationDuration, 1);
        rotationAngle = Math.PI*2 * easeOutCubic(t);
        if(t>=1){
          rotating = false;
          dancing = true;
          danceStart = ms;
        }
      }

      // Draw non-arrived hearts on top
      for(const h of hearts){
        if(h.state === 'arrived') continue;
        drawEmojiHeart(ctx, h.x, h.y, 32*h.scale, h.rot, h.alpha);
        if(h.state === 'flying'){
          const launchProgress = Math.min(h.tFly / h.flyDuration, 1);
          if(launchProgress < 0.12){
            drawMuzzleSpark(ctx, h.from.x, h.from.y, launchProgress);
          }
        }
        if(h.state === 'picked' || h.state === 'holding'){
          drawTinyGlow(ctx, h.x, h.y, 6 + 10*Math.sin(ms*0.02 + h.id));
        }
      }

      // Draw assembled arrived hearts as a rotating group
      ctx.save();
      ctx.translate(center.x, center.y);
      ctx.rotate(rotationAngle);
      ctx.translate(-center.x, -center.y);
      for(const h of hearts){
        if(h.state !== 'arrived') continue;
        drawEmojiHeart(ctx, h.target.x, h.target.y, 34*h.scale, 0, 1, 8);
      }
      ctx.restore();

      const arrivedCount = hearts.filter(h=>h.state==='arrived').length;
      if(arrivedCount >= Math.round(totalHearts*0.68)){
        ctx.save();
        ctx.font = "bold 64px Arial Rounded MT Bold, Arial, sans-serif";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'rgba(250,79,134,1)';
        ctx.shadowColor = 'rgba(255,19,97,0.95)';
        ctx.shadowBlur = 36;
        ctx.fillText('Te amo', center.x, canvas.height*0.18);
        ctx.restore();
      }

      const frame = animationTick;
      const dancePhase = dancing ? Math.min(1, (nowMs() - danceStart) / 320) : 0;
      drawTurret(ctx, turretPositions.left.x, turretPositions.left.y, 'right', anyActive, dancePhase, frame);
      drawTurret(ctx, turretPositions.right.x, turretPositions.right.y, 'left', anyActive, dancePhase, frame);

      animationTick++;
      last = ms;
      requestAnimationFrame(loop);
    }

    function drawEmojiHeart(ctx,x,y,size,rot,alpha,glow=0){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.globalAlpha = alpha;
      ctx.font = `bold ${Math.max(14, Math.round(size))}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if(glow){
        ctx.shadowColor = '#ff1361';
        ctx.shadowBlur = glow;
      }
      ctx.fillText('❤️', 0, 0);
      ctx.restore();
    }
    function drawTinyGlow(ctx,x,y,sz){
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = '#ff4f7a';
      ctx.beginPath();
      ctx.ellipse(x,y,sz,sz*0.6,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    function drawMuzzleSpark(ctx,x,y,intensity){
      ctx.save();
      const g = ctx.createRadialGradient(x,y,0,x,y,18);
      g.addColorStop(0,'rgba(255,255,255,'+(0.9*intensity)+')');
      g.addColorStop(1,'rgba(255,80,120,0)');
      ctx.fillStyle = g;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(x + (Math.random()*6-3), y + (Math.random()*6-3), 22*intensity, 8*intensity, Math.random()*0.6,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawTurret(ctx,x,y,facing,shooting,dancing,frame){
      ctx.save();
      ctx.translate(x,y);
      if(dancing){
        const bob = Math.sin(frame*0.18 + (facing==='left'?1:0))*8;
        const rot = Math.sin(frame*0.14 + (facing==='left'?2:0))*0.12;
        ctx.translate(0,bob);
        ctx.rotate(rot);
      }
      ctx.scale(facing==='left' ? -1 : 1, 1);

      if(shooting){
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.shadowColor = '#ff1361';
        ctx.shadowBlur = 18;
        ctx.beginPath();
        ctx.arc(0,0,28,0,Math.PI*2);
        ctx.fillStyle = '#ff1361';
        ctx.fill();
        ctx.restore();
      }

      ctx.beginPath();
      ctx.fillStyle = '#fff';
      ctx.arc(0,0,20,0,Math.PI*2);
      ctx.fill();

      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.arc(-7,-3,3.2,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(7,-3,3.2,0,Math.PI*2); ctx.fill();

      ctx.beginPath(); ctx.arc(0,8,7,Math.PI*0.14,Math.PI*0.86); ctx.lineWidth=2; ctx.strokeStyle='#222'; ctx.stroke();

      ctx.save();
      const base = shooting ? (Math.sin(frame*0.5)*0.18 + 0.9) : 0.1;
      ctx.rotate(-base);
      ctx.beginPath();
      ctx.lineWidth = 7;
      ctx.strokeStyle = '#fff';
      ctx.arc(-15,10,7,Math.PI*0.36,Math.PI*1.6);
      ctx.stroke();
      ctx.lineWidth = 2; ctx.strokeStyle = '#222';
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.rotate(base);
      ctx.beginPath();
      ctx.lineWidth = 7;
      ctx.strokeStyle = '#fff';
      ctx.arc(15,10,7,Math.PI*1.6,Math.PI*0.36,true);
      ctx.stroke();
      ctx.lineWidth = 2; ctx.strokeStyle = '#222';
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(0,26);
      ctx.beginPath();
      ctx.fillStyle = '#f0f0f0';
      ctx.ellipse(0,0,26,9,0,0,Math.PI*2);
      ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle='#bdbdbd';
      ctx.stroke();
      ctx.restore();

      ctx.restore();
    }

    // Auto-start when page loads
    window.addEventListener('load', ()=>{
      // slight delay so layout stabilizes
      setTimeout(()=>{ start(); }, 300);
    });

  })();
  </script>
</body>
</html>
