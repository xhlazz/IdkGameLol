// --- Retro Obby Monster-Killer ---
// Modernized, all graphics and characters menu auto-generated by script (no images needed!)

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const gui = {
  health: document.getElementById('gui-health'),
  lives: document.getElementById('gui-lives'),
  level: document.getElementById('gui-level'),
  score: document.getElementById('gui-score'),
};
const menu = document.getElementById('main-menu');
const startBtn = document.getElementById('start-btn');
const charMenuDiv = document.getElementById('character-select');
const characterDivs = document.getElementById('characters');
const fadeDiv = document.getElementById('fade');

// --- Character Data ---
const CHARACTERS = [
  {
    id: "melkin",
    name: "MElkin",
    description: "Skinny, weird hair, huge forehead. Power: Super Jump!",
    power: "High Jump (hold Shift)",
    draw: function(preview, x, y, w, h, attackFrame = 0, facing = 1) {
      const c = preview ? preview : ctx;
      c.save();
      c.translate(x + w/2, y + h/2);
      c.scale(facing, 1);
      c.translate(-w/2, -h/2);
      c.fillStyle = "#e0d1b7"; c.fillRect(6, 16, 4, 8); // legs
      c.fillStyle = "#2b4291"; c.fillRect(5, 8, 6, 10); // body
      c.fillStyle = "#e0d1b7"; c.fillRect(2, 10, 3, 5); c.fillRect(11, 10, 3, 5); // arms
      c.fillStyle = "#f2e7cf"; c.fillRect(3, 0, 10, 11); // head
      c.fillStyle = "#222"; c.fillRect(5, 0, 2, 2); c.fillRect(10, -2, 2, 4); c.fillRect(7, -3, 2, 4); // hair
      c.fillStyle = "#222"; c.fillRect(8, 6, 2, 2); // face
      if (attackFrame > 0) {
        c.fillStyle = "#fff";
        c.fillRect(15, 10, 7, 7);
      }
      c.restore();
    },
    special: function(player) {
      // Super Jump
      if (player.onGround && keys['ShiftLeft']) {
        player.vy = -9;
        player.onGround = false;
      }
    }
  },
  {
    id: "blockster",
    name: "Blockster",
    description: "Heavy and tough, big block head. Power: Damage Immunity for 2s (E)!",
    power: "Temporary Invincibility (press E)",
    draw: function(preview, x, y, w, h, attackFrame = 0, facing = 1) {
      const c = preview ? preview : ctx;
      c.save();
      c.translate(x + w/2, y + h/2);
      c.scale(facing, 1);
      c.translate(-w/2, -h/2);
      c.fillStyle = "#aa8844"; c.fillRect(4, 12, 8, 12); // body
      c.fillStyle = "#dbb066"; c.fillRect(1, 15, 3, 5); c.fillRect(12, 15, 3, 5); // arms
      c.fillStyle = "#f6e27a"; c.fillRect(2, 0, 12, 12); // head
      c.fillStyle = "#222"; c.fillRect(6, 4, 2, 2); c.fillRect(10, 4, 2, 2); // face
      if (attackFrame > 0) {
        c.fillStyle = "#fff";
        c.fillRect(16, 13, 8, 8);
      }
      c.restore();
    },
    special: function(player) {
      // Invincibility when pressing E
      if (!player.invincible && keys['KeyE']) {
        player.invincible = true;
        player.invincibleTimer = 120; // 2 seconds at 60fps
      }
      if (player.invincible) {
        player.invincibleTimer--;
        if (player.invincibleTimer <= 0) player.invincible = false;
      }
    }
  },
  {
    id: "ghosty",
    name: "Ghosty",
    description: "Fast and floaty, semi-transparent. Power: Phase through monsters (hold E)!",
    power: "Phase (hold E)",
    draw: function(preview, x, y, w, h, attackFrame = 0, facing = 1) {
      const c = preview ? preview : ctx;
      c.save();
      c.globalAlpha = 0.68;
      c.translate(x + w/2, y + h/2);
      c.scale(facing, 1);
      c.translate(-w/2, -h/2);
      c.fillStyle = "#8fd1e6"; c.beginPath(); c.ellipse(8, 14, 7, 10, 0, 0, Math.PI*2); c.fill(); // body
      c.fillStyle = "#d1f7ff"; c.beginPath(); c.ellipse(8, 7, 8, 7, 0, 0, Math.PI*2); c.fill(); // head
      c.fillStyle = "#222"; c.fillRect(5, 8, 2, 2); c.fillRect(11, 8, 2, 2); // eyes
      if (attackFrame > 0) { c.fillStyle = "#fff"; c.globalAlpha = 0.8; c.fillRect(15, 10, 7, 7);}
      c.globalAlpha = 1;
      c.restore();
    },
    special: function(player) {
      // Phase: No collision with monsters when E is pressed
      player.phasing = !!keys['KeyE'];
    }
  }
];

// --- Dynamic Character Menu Rendering ---
function renderCharacterMenu() {
  characterDivs.innerHTML = '';
  CHARACTERS.forEach((char, idx) => {
    const div = document.createElement('div');
    div.className = 'character' + (idx === 0 ? ' selected' : '');
    div.dataset.char = char.id;
    const preview = document.createElement('canvas');
    preview.width = 48; preview.height = 48;
    const pctx = preview.getContext('2d');
    char.draw(pctx, 8, 8, 32, 32, 0, 1);
    const name = document.createElement('span');
    name.textContent = char.name;
    name.style.fontWeight = "bold";
    const desc = document.createElement('div');
    desc.textContent = char.description;
    desc.className = 'char-desc';
    const pow = document.createElement('div');
    pow.textContent = char.power;
    pow.className = 'char-power';
    div.appendChild(preview);
    div.appendChild(name);
    div.appendChild(desc);
    div.appendChild(pow);
    characterDivs.appendChild(div);
  });
}

// --- State ---
let selectedCharIdx = 0;
let selectedChar = CHARACTERS[0].id;
let player, monsters, level, score, health, lives, currentLevel, gameState = "menu";

function getSelectedCharacter() {
  return CHARACTERS.find(c => c.id === selectedChar);
}

// --- GAME OBJECTS ---
function resetPlayer() {
  player = {
    x: 32, y: 208, vx: 0, vy: 0,
    w: 16, h: 24,
    dir: 1,
    onGround: false,
    attackFrame: 0,
    character: selectedChar,
    invincible: false,
    invincibleTimer: 0,
    phasing: false
  };
  health = 3;
}

function resetMonsters(monsterDefs) {
  monsters = monsterDefs.map(def => ({
    x: def.x,
    y: def.y,
    w: 16,
    h: 16,
    type: def.type,
    hp: 1,
    dir: Math.random() < 0.5 ? -1 : 1,
    alive: true,
  }));
}

function loadLevel(n) {
  currentLevel = n;
  const levels = [
    {
      tiles: [
        "........................",
        "........................",
        "...................M....",
        "........................",
        ".............####.......",
        "........................",
        "......###...............",
        "........................",
        "########################"
      ],
      monsters: [{x: 320, y: 176, type: 'monster1'}]
    },
    {
      tiles: [
        "........................",
        "..#.....................",
        "....................M...",
        "....................#...",
        "............#####.......",
        "........................",
        ".....###.........###....",
        "........................",
        "########################"
      ],
      monsters: [{x: 380, y: 128, type: 'monster1'}]
    }
  ];
  let lvl = levels[n % levels.length];
  level = lvl;
  resetPlayer();
  resetMonsters(lvl.monsters);
}

// --- INPUT HANDLING ---
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
});
window.addEventListener('keyup', e => {
  keys[e.code] = false;
});

// --- GAME LOOP ---
function update() {
  if (gameState !== "playing") return;

  // Character powers
  const char = getSelectedCharacter();
  if (char && char.special) char.special(player);

  // Movement
  let speed = 2.1;
  if (player.character === "ghosty") speed = 2.7;
  if (keys['ArrowLeft']) { player.vx = -speed; player.dir = -1; }
  else if (keys['ArrowRight']) { player.vx = speed; player.dir = 1; }
  else player.vx = 0;

  // Jump
  let jumpPower = -6;
  if (player.character === "melkin" && keys['ShiftLeft']) jumpPower = -9;
  if (keys['Space'] && player.onGround) {
    player.vy = jumpPower;
    player.onGround = false;
  }

  // Gravity
  player.vy += 0.34;
  player.y += player.vy;
  player.x += player.vx;

  // Collision (simplified)
  let ground = 232;
  if (player.y + player.h > ground) {
    player.y = ground - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  // Obby tiles
  for (let y = 0; y < level.tiles.length; ++y) {
    for (let x = 0; x < level.tiles[0].length; ++x) {
      if (level.tiles[y][x] === "#") {
        let tx = x * 16, ty = y * 16;
        if (rectsCollide(player, {x: tx, y: ty, w: 16, h: 16})) {
          // Push player up
          if (player.vy > 0) {
            player.y = ty - player.h;
            player.vy = 0;
            player.onGround = true;
          } else if (player.vy < 0) {
            player.y = ty + 16;
            player.vy = 0;
          }
        }
      }
    }
  }

  // Attack
  if (keys['KeyZ'] && player.attackFrame === 0) {
    player.attackFrame = 10;
  }
  if (player.attackFrame > 0) player.attackFrame--;

  // Monster logic
  for (const m of monsters) {
    if (!m.alive) continue;
    m.x += m.dir * 1;
    if (Math.random() < 0.01) m.dir *= -1;

    // Collide with player
    const collide = rectsCollide(player, m);
    let canHurt = true;
    if (player.character === "blockster" && player.invincible) canHurt = false;
    if (player.character === "ghosty" && player.phasing) canHurt = false;

    if (collide && canHurt) {
      if (player.attackFrame > 0 && Math.abs(player.x - m.x) < 20) {
        m.hp -= 1;
        if (m.hp <= 0) {
          m.alive = false;
          score += 100;
        }
      } else {
        health -= 1;
        if (health <= 0) {
          lives -= 1;
          if (lives > 0) {
            resetPlayer();
          } else {
            gameState = "gameover";
            setTimeout(showMenu, 2000);
          }
        }
      }
    } else if (collide && !canHurt) {
      // Blockster/ghosty: can destroy monsters while powered up
      if (player.attackFrame > 0 && Math.abs(player.x - m.x) < 20) {
        m.hp -= 1;
        if (m.hp <= 0) {
          m.alive = false;
          score += 100;
        }
      }
    }
  }

  // Level end: reach far right
  if (player.x > 480) {
    fadeInOut(() => {
      loadLevel(currentLevel + 1);
      score += 500;
    });
  }
}

function draw() {
  // Layered retro background
  ctx.fillStyle = "#1e2340";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Distant mountains
  for (let i=0; i<6; ++i) {
    ctx.fillStyle = `rgba(70,110,${170+20*i},${0.12+0.05*i})`;
    ctx.beginPath();
    ctx.moveTo(-40 + i*80, 160+10*i);
    ctx.lineTo(100+i*55, 70+16*i);
    ctx.lineTo(220+i*60, 170+22*i);
    ctx.lineTo(350+i*70, 90+10*i);
    ctx.lineTo(600, 250+25*i);
    ctx.lineTo(0, 320);
    ctx.closePath();
    ctx.fill();
  }
  // Retro pixel stars
  for (let i=0; i<32; ++i) {
    ctx.fillStyle = "#fff8";
    ctx.fillRect((i*31)%512, (i*73)%180, 1, 1);
  }
  // Ground
  ctx.fillStyle = "#4fd4f6";
  ctx.fillRect(0, 240, canvas.width, 80);

  // Tiles
  for (let y = 0; y < level.tiles.length; ++y) {
    for (let x = 0; x < level.tiles[0].length; ++x) {
      let t = level.tiles[y][x];
      if (t === "#") {
        ctx.fillStyle = "#262e53";
        ctx.fillRect(x*16, y*16, 16, 16);
        ctx.strokeStyle = "#4fd4f6";
        ctx.strokeRect(x*16, y*16, 16, 16);
      }
    }
  }

  // Monsters
  for (const m of monsters) {
    if (!m.alive) continue;
    drawMonster(m.x, m.y, m.w, m.h);
  }

  // Player
  let char = getSelectedCharacter();
  char.draw(null, player.x, player.y, player.w, player.h, player.attackFrame, player.dir);

  // GUI
  gui.health.textContent = "♥ ".repeat(health);
  gui.lives.textContent = `Lives: ${lives}`;
  gui.level.textContent = `Level ${currentLevel+1}/50`;
  gui.score.textContent = `Score: ${score}`;
}

// --- Monster by code ---
function drawMonster(x, y, w, h) {
  ctx.save();
  ctx.translate(x, y);
  ctx.fillStyle = "#7d2e2e";
  ctx.fillRect(0, 4, w, h-4); // body
  ctx.fillStyle = "#b13b3b";
  ctx.fillRect(2, 0, w-4, 8); // head
  ctx.fillStyle = "#fff";
  ctx.fillRect(4, 3, 2, 2); ctx.fillRect(10, 3, 2, 2); // eyes
  ctx.fillStyle = "#000";
  ctx.fillRect(5, 4, 1, 1); ctx.fillRect(11, 4, 1, 1); // pupils
  ctx.fillStyle = "#fff";
  ctx.fillRect(7, 12, 2, 2); // teeth
  ctx.restore();
}

function rectsCollide(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

// --- MENU AND GAME START ---
function setCharSelection(idx) {
  selectedCharIdx = idx;
  selectedChar = CHARACTERS[idx].id;
  Array.from(characterDivs.children).forEach((d, i) => d.classList.toggle('selected', i===idx));
}
function setupMenuEvents() {
  Array.from(characterDivs.children).forEach((div, idx) => {
    div.addEventListener('click', () => setCharSelection(idx));
  });
}
function showMenu() {
  fadeDiv.style.display = "block";
  setTimeout(()=>{
    fadeDiv.style.opacity = 0.68;
    setTimeout(()=>{
      menu.style.display = "";
      canvas.style.display = "none";
      document.getElementById('gui').style.display = "none";
      fadeDiv.style.opacity = 0;
      setTimeout(()=>{fadeDiv.style.display = "none";}, 650);
    }, 650);
  }, 10);
}
function fadeInOut(cb) {
  fadeDiv.style.display = "block";
  fadeDiv.style.opacity = 0;
  setTimeout(()=>{ fadeDiv.style.opacity = 0.68; }, 10);
  setTimeout(()=>{
    cb();
    fadeDiv.style.opacity = 0;
    setTimeout(()=>{fadeDiv.style.display = "none";}, 600);
  }, 650);
}
startBtn.addEventListener('click', () => {
  fadeDiv.style.display = "block";
  fadeDiv.style.opacity = 0.68;
  setTimeout(()=>{
    menu.style.display = "none";
    canvas.style.display = "block";
    document.getElementById('gui').style.display = "flex";
    score = 0; lives = 3;
    loadLevel(0);
    gameState = "playing";
    fadeDiv.style.opacity = 0;
    setTimeout(()=>{fadeDiv.style.display = "none"; gameLoop();}, 650);
  }, 700);
});

// --- GAME LOOP ---
function gameLoop() {
  if (gameState === "playing") {
    update();
    draw();
  } else if (gameState === "gameover") {
    ctx.fillStyle = "#000a";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.font = "24px monospace";
    ctx.fillText("GAME OVER", 170, 160);
    ctx.font = "12px monospace";
    ctx.fillText("Returning to menu...", 135, 195);
  }
  if (gameState === "playing") requestAnimationFrame(gameLoop);
}

// --- INIT ---
window.onload = () => {
  renderCharacterMenu();
  setupMenuEvents();
  setCharSelection(0);
};
